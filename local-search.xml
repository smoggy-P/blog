<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Convex Optimization Note(3): Convex Optimization</title>
    <link href="/blog/2023/11/01/Convex%20Optimization(3)/"/>
    <url>/blog/2023/11/01/Convex%20Optimization(3)/</url>
    
    <content type="html"><![CDATA[<h1 id="optimization-formulation">1. Optimization Formulation</h1><h2 id="eliminating-linear-equality-constraints">Eliminating LinearEquality Constraints</h2><p>For a linear equation constraints <spanclass="math inline">\(Ax=b\)</span>, supposing the correspondingfeasible set is <span class="math inline">\(S=\{x|Ax=b\}\)</span>. Theconstraint can be eliminated by substituting <spanclass="math inline">\(x\)</span> with <spanclass="math inline">\(x_0+Fz\)</span> where <spanclass="math inline">\(x_0\)</span> is a particular solution of <spanclass="math inline">\(Ax=b\)</span> and <spanclass="math inline">\(F\)</span> is a basis of the null space of <spanclass="math inline">\(A\)</span>. Thus, we do not need constraints onvariable <span class="math inline">\(z\)</span>.</p><p>Conditions: <span class="math inline">\(RF=ker\ A\)</span>, <spanclass="math inline">\(x_0\in S\)</span></p><p><span class="math display">\[x\in S \iff x-x_0\in ker\ A \iffx-x_0\in RF\iff x-x_0=Fz\]</span></p><blockquote><p>Null space of matrix <span class="math inline">\(A\)</span>: <spanclass="math inline">\(ker\ A=\{x|Ax=0\}\)</span></p></blockquote><blockquote><p>Range of matrix <span class="math inline">\(F\)</span>: <spanclass="math inline">\(RF=\{Fx|x\in\mathbb{R}^n\}\)</span></p></blockquote><h1 id="convex-optimization">2. Convex Optimization</h1><p>Basic formulation of convex optimization problem:</p><p><span class="math display">\[\begin{aligned}    \min_{x\in\mathbb{R}^n}&amp;f_0(x)\\s.t. &amp;f_i(x)\leq0,\ i=1,...,m\\&amp;a_i^Tx=b_i,\ i=1,...,p\end{aligned}\]</span></p><p>where:</p><ul><li><p><span class="math inline">\(f_0, f_1\dotsf_m:\mathbb{R}^n\rightarrow\mathbb{R}\)</span> is convex</p></li><li><p><span class="math inline">\(h_i\)</span> is affine</p></li></ul><h2 id="optimality-conditions">Optimality Conditions</h2><p>In convex optimization, a local minimum is also a global minimum. Theoptimal condition is: <spanclass="math display">\[\nabla^Tf(x)(y-x)\geq0,\ \forall y\in\text{feasible set}\]</span> Geometrically, it means that <spanclass="math inline">\(-\nabla^Tf(x)\)</span> is a supporting hyperplaneof the feabile set at <span class="math inline">\(x\)</span>. (if <spanclass="math inline">\(\nabla f(x) \neq 0\)</span>)</p><p><img src="/blog/img/optimal_condition.png" /></p><ul><li><p>Unconstrained problem: <span class="math inline">\(\nablaf(x)=0\)</span></p></li><li><p>Problem with only equality constraints: <spanclass="math display">\[  \begin{aligned}    \min_{x}\quad&amp;f(x)  \\s.t. \quad &amp;Ax=b  \end{aligned}  \]</span> <span class="math inline">\(y-x\in \mathcal{N}(A)\)</span>since they are both in the feasible set. Thus, <spanclass="math inline">\(\nabla f(x) \perp \mathcal{N}(A)\)</span> &gt; Ifa linear function is non-negative on a subspace, then it must be zero onthis subspace.</p></li><li><p>Non-negative orthant <span class="math display">\[  \begin{aligned}    \min_{x}\quad&amp;f(x)  \\s.t. \quad &amp;x\succeq 0  \end{aligned}  \]</span> After deduction, we can get <spanclass="math inline">\(x_i(\nabla f(x))_i= 0\)</span>, which is acomplementarity condition. This can also be achieved by KKTcondition.</p></li></ul><h1 id="quasi-convex-optimization">Quasi-convex Optimization</h1><p>Only the cost function is quasi-convex compared to convexoptimization. For quasi-convex constraints, we can always find a convexconstraints that is equivalent to the original one(same 0-levelsubset).</p><p><span class="math display">\[\nabla^Tf(x)(y-x)&gt;0\quad \forall y\in\mathcal{X}/x \implies x \text{ is global optimal}\]</span></p><ul><li><p>Only sufficient</p></li><li><p>gradient non-zero</p></li></ul><h2id="bisection-method-from-quasi-convex-to-convex-optimization">BisectionMethod: From quasi-convex to convex optimization</h2><p>For a quasi-convex problem, we can use bisection method to find theoptimal solution. The idea is to use a convex function family <spanclass="math inline">\(\phi_t(x)\)</span> to approximate the originalfunction <span class="math inline">\(f(x)\)</span>: <spanclass="math display">\[f(x)\leq t \iff \phi_t(x)\leq 0\]</span> Then tryto approximate the optimal solution <spanclass="math inline">\(p^*\)</span>: <imgsrc="/blog/img/bisection_method.png" /></p><h1 id="linear-optimization">Linear Optimization</h1><p>All the constraints and objective are affine.</p><p><span class="math display">\[\begin{aligned}\min\quad &amp; c^Tx+d\\s.t.\quad &amp; Gx\leq h\\&amp; Ax=b\end{aligned}\]</span></p><p>Geometric interpretation of linear optimization: <imgsrc="/blog/img/lp_opt.png" /></p><h2 id="linear-fractional-programming">Linear-fractionalProgramming</h2><p>The objective is a ratio of affine functions: <spanclass="math display">\[f_0(x)=\frac{c^Tx+d}{e^Tx+f}\]</span> This is a quasi-convex optimization.</p><h1 id="quadratic-optimization">Quadratic Optimization</h1><p>The objective is a quadratic function and the constraints are affine.<span class="math display">\[\begin{aligned}\min\quad &amp; \frac{1}{2}x^TPx+q^Tx+r\\s.t.\quad &amp; Gx\leq h\\&amp; Ax=b\end{aligned}\]</span></p><p>If the inequality constraints are quadratic(convex), the problem iscalled <strong>quadratically constrained quadraticprogramming(QCQP)</strong>. If the constraint can be written as <spanclass="math inline">\(||Ax+b||_2\leq c^Tx+d\)</span>, it is called<strong>second-order cone programming(SOCP)</strong>. Their relationshipcan be expressed as following: <img src="\blog\img\qcqp_socp.png" /></p><blockquote><p>Example of a robust linear programming problem: <spanclass="math display">\[\begin{aligned}\min\quad &amp; c^Tx\\s.t.\quad &amp; a_i^Tx\leq b_i,\ i=1,...,m\end{aligned}\]</span> The <span class="math inline">\(a_i\)</span> lie in aelipsoid: <span class="math display">\[\begin{aligned}a_i\in\mathcal{E}_i=\{a_c+P_iu\quad|\quad ||u||_2\leq 1\}\end{aligned}\]</span> The constraint can be reduced to: <spanclass="math display">\[\begin{aligned}a_c^Tx+||P_i^Tx||_2\leq b_i\end{aligned}\]</span> Which is a SOCP. With similar method, we can transfer a randomlinear constrained problem into an SOCP problem: <spanclass="math display">\[\textbf{Prob}(a_i^Tx\leq b_i)\geq\Phi\]</span></p></blockquote><h1 id="geometric-programming">Geometric Programming</h1><p>Forms that are not convex originally but can be transferred into aconvex function by its Monomials and Posynomials formed constraints.</p><p>Monomials: <span class="math inline">\(f(x)=cx_1^{a_1}x_2^{a_2}\dotsx_i^{a_i}\)</span></p><p>Posynomials: Linear combinations of monomials</p><h1id="convex-optimization-in-the-form-of-generalized-inequality">ConvexOptimization in the form of Generalized Inequality</h1><p>The standard form of convex optimization can also be expressedthrough generalized inequality. In the following chapters, we will seethis can also be solved as easily as ordinary convex optimizationproblems. <span class="math display">\[\begin{array}{ll}\operatorname{minimize} &amp; f_0(x) \\\text { subject to } &amp; f_i(x) \preceq_{ \text { K }_i} 0, \quad i=1,\ldots, m \\&amp; A x=b,\end{array}\]</span></p><h2 id="conic-form-problems">Conic Form Problems</h2><p>The conic form problem is a special case of the generalizedinequality problem. It has a <strong>linear objective</strong> and oneaffine inequality constraint: <span class="math display">\[\begin{array}{ll}\operatorname{minimize} &amp; c^Tx \\\text { subject to } &amp; Ax+b \preceq_{ \text { K }} 0\end{array}\]</span> If <span class="math inline">\(K\)</span> is the non-negativeorthant, the problem is a linear programming problem.</p><h2 id="semi-definite-programming">Semi-definite Programming</h2><p>The semi-definite programming is a special case of the conic formproblem when <span class="math inline">\(K \in S_+^k\)</span> is thecone of positive semi-definite matrices. <span class="math display">\[\begin{array}{ll}\operatorname{minimize} &amp; c^T x \\\text { subject to } &amp; x_1 F_1+\cdots+x_n F_n+G \preceq 0 \\&amp; A x=b,\end{array}\]</span></p><blockquote><p>The inequality constraint is a linear matrix inequality(LMI) if <spanclass="math inline">\(F_i,G\)</span> are diagonal.</p></blockquote><p>Here is an example of converting a non-convex problem into asemi-definite programming(thus convex) problem through "lifting". It isjust a simple example to leave some impression of SDP. We will see moreexamples in the following chapters.</p><p><img src="/blog/img/sdp.png" /></p>]]></content>
    
    
    <categories>
      
      <category>Convex Optimization</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Convex Optimization Note(2): Convex Function</title>
    <link href="/blog/2023/10/30/Convex%20Optimization(2)/"/>
    <url>/blog/2023/10/30/Convex%20Optimization(2)/</url>
    
    <content type="html"><![CDATA[<p>中文版笔记感觉<ahref="https://chriszhangcx.github.io/%E5%87%B8%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0-2-%E5%87%B8%E5%87%BD%E6%95%B0/">这个博主</a>总结的比较清楚</p><h1 id="convex-function">1. Convex Function</h1><p>Convex can also be used to describe the feature of a function.</p><p><strong>Definition:</strong> <span class="math display">\[f(\thetax+(1-\theta) y)\leq\theta f(x) + (1-\theta)f(y)\]</span></p><p><strong>Conditions:</strong></p><ul><li><p>First Order: <span class="math inline">\(f(x) + \nablaf(x)^T(y-x)\leq f(y)\)</span></p></li><li><p>Second Order: <spanclass="math inline">\(\nabla^2f\succeq0\)</span> (positive semi-definiteHessian Matrix)</p><blockquote><p>Semi-definite: <spanclass="math inline">\(\nabla^2f(x)\succeq0\)</span> means that <spanclass="math inline">\(\forall y\in\mathbb{R}^n\)</span>, <spanclass="math inline">\(y^T\nabla^2f(x)y\geq0\)</span></p></blockquote></li></ul><p><strong>Examples:</strong></p><ul><li><p><em>Norm</em>: Any norm <spanclass="math inline">\(f(x):\mathbb{R}^n\rightarrow\mathbb{R}\)</span> iscovex</p></li><li><p><em>Max</em>: max function is convex</p></li><li><p><em>Geometric Mean</em>: <spanclass="math inline">\(f(x)=(\prod_{i=1}^nx_i)^{1/n}\)</span> concave,prove by second-order condition</p></li></ul><h2 id="sublevelsuperlevel-sets">Sublevel/Superlevel Sets</h2><p><strong>Definition:</strong> <spanclass="math display">\[C_{\alpha}=\{x\in\textbf{dom}f|f(x)\leq\alpha\}\]</span> <strong>Property:</strong> All sublevelsets of convex function are convex sets(converse not).</p><blockquote><p>It is said to be a good way to construct convex sets.</p></blockquote><h2 id="epigraph">Epigraph</h2><p>Epi means "above" so epigraph basically means area above thefunction. We should notice that the epigraph actually <strong>expandsthe dimension</strong> of the original function. That is, if <spanclass="math inline">\(f:\mathbb{R}^n\rightarrow\mathbb{R}\)</span>, then<span class="math inline">\(\textbf{epi}f\subset\mathbb{R}^{n+1}\)</span>.</p><p><strong>Definition:</strong> <span class="math display">\[\textbf{epi}f=\{(x,t)|f(x)\leq t, x\in\textbf{dom }f\}\]</span></p><p><img src="/blog/img/epigraph.png" /></p><h2 id="jensens-inequality">Jensen's inequality</h2><p>Convex Combination for more than 2 points: <spanclass="math display">\[f(\theta_1 x_1+\dots\theta_kx_k)\leq\theta_1f(x_1)+\dots \theta_kf(x_k)\]</span> It can befurther proved about expectation: <spanclass="math display">\[f(\mathbb{E}(x))\leq\mathbb{E}(f(x))\]</span></p><h1 id="operations-pereserve-convexity">2. Operations pereserveConvexity</h1><ul><li><p>Non-negative weighted sum</p></li><li><p>Affine mapping <spanclass="math inline">\(g(x)=f(Ax+b)\)</span></p></li><li><p>Maximum <spanclass="math inline">\(f(x)=\max\{f_1(x)+f_2(x)\}\)</span></p><blockquote><p>It can further be prove that <spanclass="math inline">\(f(x)=\sup_{y\in A}||x-y||\)</span> isconvex.(furthest distance from a set)</p></blockquote><blockquote><p>Almost every convex function can be represented as the supremum of afamily of affine functions.</p></blockquote></li><li><p>Composition <span class="math inline">\(f(x)=g(h(x))\)</span>,not necessarily convex, look at the expression of <spanclass="math inline">\(f&#39;&#39;(x)\)</span></p></li><li><p>Minimization: <span class="math inline">\(f(x)=\inf_{y\inA}f(x,y)\)</span> is convex if <spanclass="math inline">\(f(x,y)\)</span> is convex and <spanclass="math inline">\(A\)</span> is convex set(Additional requirement onconvexity of <span class="math inline">\(A\)</span>).</p></li><li><p>Perspective: <span class="math inline">\(f(x)=t\cdotf(x/t)\)</span> is convex if <span class="math inline">\(f(x)\)</span>is convex and <span class="math inline">\(t&gt;0\)</span>.</p></li><li><p>Conjugate function: <spanclass="math inline">\(f^*(y)=\sup_{x\in\textbf{dom}}(y^Tx-f(x))\)</span> is convex regardless of the convexity of <spanclass="math inline">\(f(x)\)</span>.</p><blockquote><p>The maximum distance between <spanclass="math inline">\(f(x)\)</span> and line <spanclass="math inline">\(y=x\)</span>: <imgsrc="/blog/img/conjugate.png" /></p></blockquote></li></ul><h1 id="quasiconvex-function">3. Quasiconvex Function</h1><p><strong>Definition:</strong> If all sublevel sets of <spanclass="math inline">\(f(x)\)</span> are convex, then <spanclass="math inline">\(f(x)\)</span> is quasiconvex. One example of a setthat is quasi-convex but not convex: <imgsrc="/blog/img/quasi_convex.png" /></p><p><strong>Property:</strong></p><ul><li><span class="math inline">\(f(\theta x_1+(1-\theta)x_2)\leq\max\{f(x_1),f(x_2)\}\)</span></li></ul><p><strong>Conditions:</strong></p><ul><li><p>First Order: <spanclass="math inline">\(f(y)&lt;f(x)\implies\nabla f(x)^T(y-x)\leq0\)</span></p></li><li><p>Second Order: <span class="math inline">\(\forall y\inR^n\)</span>, <span class="math inline">\(y^T\nablaf(x)\implies\)</span> <spanclass="math inline">\(y^T\nabla^2f(x)y\succeq 0\)</span></p></li></ul><h1 id="log-concave-function-and-log-convex-function">4. Log-ConcaveFunction and Log-Convex Function</h1><p><strong>Definition:</strong> Log-Concave: <spanclass="math inline">\(f(x)\)</span> is log-concave if <spanclass="math inline">\(\log f(x)\)</span> is concave. <spanclass="math display">\[f(\theta x_1+(1-\theta)x_2)\geqf(x_1)^{\theta}f(x_2)^{1-\theta}\]</span></p>]]></content>
    
    
    <categories>
      
      <category>Convex Optimization</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Convex Optimization Note(1): Affine Set and Convex Set</title>
    <link href="/blog/2023/10/28/Convex%20Optimization(1)/"/>
    <url>/blog/2023/10/28/Convex%20Optimization(1)/</url>
    
    <content type="html"><![CDATA[<h1 id="convex-sets">1. Convex Sets</h1><h2 id="affine-set-c">1.1 Affine Set <spanclass="math inline">\(C\)</span></h2><p><strong>Definition</strong>: <span class="math inline">\(\forallx_1,x_2\in C, \theta x_1+(1-\theta) x_2 \in C\)</span></p><p><strong>Property</strong>:</p><ul><li><p>Solution Set of Linear Equation <spanclass="math inline">\(\iff\)</span> Affine Set(线性方程的解集是affineset，同时affine set都能写成线性方程的解)</p></li><li><p>Subspace: <span class="math inline">\(V=C-x_0\)</span> where<span class="math inline">\(x_0\in C\)</span>(无论选择哪个<spanclass="math inline">\(x_0\)</span>，subspace <spanclass="math inline">\(V\)</span>始终能穿过原点)</p></li></ul><h2 id="affine-hull-textbfaff-c">1.2 Affine Hull <spanclass="math inline">\(\textbf{aff }C\)</span></h2><p><strong>Definition</strong>: All affine combinations of points in set<span class="math inline">\(C\)</span></p><p><strong>Property</strong>: Smallest affine set that contains <spanclass="math inline">\(C\)</span></p><p><strong>Example</strong>: Affine set of a circle <spanclass="math inline">\(\left\{(x_1,x_2)\in\mathbb{R}^2|x_1^2+x_2^2=1\right\}\)</span>is <span class="math inline">\(\mathbb{R^2}\)</span>, the <em>affinedimesion</em> is 2.</p><h2 id="convex-set">1.3 Convex Set</h2><p><strong>Definition:</strong> Affine set with <spanclass="math inline">\(\theta \in [0,1]\)</span>, we have similarly<em>Convex Hull</em></p><p><strong>Property:</strong></p><ul><li><p>works for infinite sums and integral</p></li><li><p>pass through expectation</p></li></ul><h2 id="conenon-negative-homogeneous">1.4 Cone(non-negativehomogeneous)</h2><p><strong>Definition:</strong> <span class="math inline">\(\forall x\inC\text{ and } \theta &gt; 0, \theta x\in C\)</span></p><h2 id="simplex">1.5 Simplex</h2><p><strong>Definition:</strong> Convex hull of <spanclass="math inline">\(k+1\)</span> affine independent vector</p><blockquote><p>affine independent: 直观理解与线性相关定义类似，数学表达上对于<spanclass="math inline">\(v_0,v_1\dots v_{k}\)</span>，如果<spanclass="math inline">\((v_1-v_0,v_2-v_0\dotsv_k-v_0)\)</span>线性无关，则这k+1个向量仿射无关。值得一提的是对于二维平面，要证明四个及以上向量仿射无关就需要证明三个及以上二维向量线性无关，而三个二维向量必定线性相关，因此不存在四个及以上仿射相关的二维向量，因此<span class="math inline">\(\mathbb{R}^2\)</span>中的simplex只可能是三角形（而不会是四边形或更多边形）。</p></blockquote><h2 id="positive-semi-definite-cone">1.6 Positive Semi-definiteCone</h2><p><strong>Definition:</strong> Set of Semi-definite matrix <spanclass="math inline">\(S_+^n=\left\{X\in\mathbb{R}^{n\timesn}|X^T=X,X\succeq0\right\}\)</span></p><p><strong>Property:</strong> This set is a convex cone.(任意两个半正定矩阵线性组合，系数为正的情况下，结果仍为半正定矩阵)</p><h1 id="operation-that-preserves-convexity">2. Operation that preservesconvexity</h1><ul><li><p><strong>Intersection</strong> of convex sets is stillconvex</p></li><li><p><strong>Affine Function</strong> projects convex sets to convexsets</p><blockquote><p>Affine Function: 等同于线性变换</p></blockquote></li><li><p><strong>Perspective Function</strong> -&gt;<strong>Linear-Fractional Function</strong></p><blockquote><p><span class="math inline">\((x_1,x_2,x_3)\)</span> to <spanclass="math inline">\((\frac{x_1}{x_3}, \frac{x_2}{x_3}, 1)\)</span></p></blockquote></li></ul><h1 id="general-inequality">3. General Inequality</h1><h2 id="proper-cone">3.1 Proper Cone</h2><p>Convex; Closed; Solid(non-emplty interior); Pointed(不超过半平面)</p><h2 id="inequality">3.2 Inequality</h2><p>Let <span class="math inline">\(K\)</span> be a proper cone in vectorspace <span class="math inline">\(V\)</span>, we say vector <spanclass="math inline">\(x\)</span> is greater than <spanclass="math inline">\(y\)</span> with respect to <spanclass="math inline">\(K\)</span> when we have <spanclass="math inline">\(x-y\in K\)</span>. Denoted as: <spanclass="math display">\[x\succeq_Ky\]</span></p><h1 id="seperating-and-supporting-hyperplane">4. Seperating andsupporting hyperplane</h1><!-- # 4.1 Seperating --><p><em>Seperating hyperplane</em>: For two convex sets that aredisjoint(no intersection), there exists a hyperplane that seperatesthese two sets.</p><p><em>Converse theorm</em>: If at least one convex set is open,existing seperating hyperplane means disjoint sets.</p><p><em>Supporting hyperplane:</em> Seperating hyperplane on a boundarypoint</p><h1 id="dual-cone">5. Dual Cone</h1><p><strong>Definition:</strong> For a cone <spanclass="math inline">\(K\)</span>, the dual cone is defined as: <spanclass="math display">\[K^*=\left\{y|x^Ty\geq0, \forall x\inK\right\}\]</span></p><blockquote><p>几何上可以理解为与所有目标锥内的向量夹角都不超过90度的向量构成的锥</p></blockquote><p><strong>Property:</strong></p><ul><li><span class="math inline">\(x\)</span> is the minimum element of set<span class="math inline">\(S\)</span> with respect to <spanclass="math inline">\(K\)</span>, it means that for <spanclass="math inline">\(\lambda\succeq_{K^*}0\)</span>, <spanclass="math inline">\(x\)</span> is the minimizer of <spanclass="math inline">\(\lambda^Tz\)</span> over <spanclass="math inline">\(z\in S\)</span></li></ul>]]></content>
    
    
    <categories>
      
      <category>Convex Optimization</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu Lagging Solutions</title>
    <link href="/blog/2023/08/04/Ubuntu%20Lagging%20Solutions/"/>
    <url>/blog/2023/08/04/Ubuntu%20Lagging%20Solutions/</url>
    
    <content type="html"><![CDATA[<p>最近解决了一下ubuntu卡顿的情况，梳理了一下造成卡顿的一些原因，便于之后排查。</p><h1 id="显卡驱动问题">1. 显卡驱动问题</h1><p>ubuntu本身默认没有nvidia显卡驱动，需要手动安装，这里的过程不再赘述。判断显卡驱动有没有出问题可以通过以下几种渠道：</p><ul><li>设置-&gt;关于选项下查看显卡是否为独立显卡，如果驱动没有起作用，这里会显示核显。<p style="text-align: center;"><img src="/blog/img/ubuntu/gpu.png" width=400></p></li><li>在命令行输入 <code>nvidia-smi</code> 观察是否有输出 <figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+-----------------------------------------------------------------------------+<br>|<span class="hljs-string"> NVIDIA-SMI 470.199.02   Driver Version: 470.199.02   CUDA Version: 11.4     </span>|<br>|<span class="hljs-string">-------------------------------+----------------------+----------------------+</span><br><span class="hljs-string"></span>|<span class="hljs-string"> GPU  Name        Persistence-M</span>|<span class="hljs-string"> Bus-Id        Disp.A </span>|<span class="hljs-string"> Volatile Uncorr. ECC </span>|<br>|<span class="hljs-string"> Fan  Temp  Perf  Pwr:Usage/Cap</span>|<span class="hljs-string">         Memory-Usage </span>|<span class="hljs-string"> GPU-Util  Compute M. </span>|<br>|<span class="hljs-string">                               </span>|<span class="hljs-string">                      </span>|<span class="hljs-string">               MIG M. </span>|<br>|<span class="hljs-string">===============================+======================+======================</span>|<br>|<span class="hljs-string">   0  NVIDIA GeForce ...  Off  </span>|<span class="hljs-string"> 00000000:01:00.0  On </span>|<span class="hljs-string">                  N/A </span>|<br>|<span class="hljs-string"> N/A   59C    P8     3W /  N/A </span>|<span class="hljs-string">    597MiB /  3911MiB </span>|<span class="hljs-string">      6%      Default </span>|<br>|<span class="hljs-string">                               </span>|<span class="hljs-string">                      </span>|<span class="hljs-string">                  N/A </span>|<br>+-------------------------------+----------------------+----------------------+<br>                                                                               <br>+-----------------------------------------------------------------------------+<br>|<span class="hljs-string"> Processes:                                                                  </span>|<br>|<span class="hljs-string">  GPU   GI   CI        PID   Type   Process name                  GPU Memory </span>|<br>|<span class="hljs-string">        ID   ID                                                   Usage      </span>|<br>|<span class="hljs-string">=============================================================================</span>|<br>|<span class="hljs-string">    0   N/A  N/A      1584      G   /usr/lib/xorg/Xorg                 70MiB </span>|<br>|<span class="hljs-string">    0   N/A  N/A      2420      G   /usr/lib/xorg/Xorg                222MiB </span>|<br>|<span class="hljs-string">    0   N/A  N/A      2616      G   /usr/bin/gnome-shell               62MiB </span>|<br>|<span class="hljs-string">    0   N/A  N/A      6695      G   ...RendererForSitePerProcess      206MiB </span>|<br>|<span class="hljs-string">    0   N/A  N/A     13625      G   ...824728346665869974,262144       25MiB </span>|<br>+-----------------------------------------------------------------------------+<br><br></code></pre></td></tr></table></figure>---</li></ul><h1 id="显卡使用模式">2. 显卡使用模式</h1>在确认显卡驱动成功起作用之后，我们仍然不能确认显卡在工作，这也是我这次遇到的情况。在通过<code>apt upgrade</code>自动升级显卡驱动后，我发现新安装的显卡驱动默认采用"on-demand"模式。一般情况下显卡都处于闲置状态。我们可以通过以下简单测试看看显卡是否正在工作。- 在终端内输入<code>watch nvidia-smi</code>，注意持续观察下半部分"Process" -打开firefox浏览器，观察Process部分有没有新增firefox的进程，如果没有就证明GPU处于on-demand模式- 在终端输入<code>nvidia-settings</code>，将模式调整为PerformanceMode，之后reboot<p style="text-align: center;"><img src="/blog/img/ubuntu/gpu_set.png" width=400></p><h1 id="cpu使用模式">3. CPU使用模式</h1><p>部分情况下CPU也会处于ondemand模式，可以通过<code>cpufrequtils</code>进行调整： <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 安装cpufreq工具</span><br>sudo apt install cpufrequtils<br><span class="hljs-comment"># 检查CPU频率是否是最大状态</span><br>cpufreq-<span class="hljs-built_in">info</span><br><span class="hljs-comment"># 调整CPU模式</span><br>cpufreq-<span class="hljs-built_in">set</span> -g performance<br></code></pre></td></tr></table></figure>值得一提的是这个设置重启会被重置，之后再看看有没有保留设定的方法。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>用Solidworks对无人机进行拓扑优化</title>
    <link href="/blog/2022/08/26/%E7%94%A8Solidworks%E8%BF%9B%E8%A1%8C%E6%8B%93%E6%89%91%E4%BC%98%E5%8C%96/"/>
    <url>/blog/2022/08/26/%E7%94%A8Solidworks%E8%BF%9B%E8%A1%8C%E6%8B%93%E6%89%91%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>暑研期间帮师兄出了一版无人机的图，在画完基本框架后想通过拓扑优化的方法对机身进行减重。之前进行拓扑优化都是在ansysworkbench里，在我尝试把模型导入ansys的过程中出现了很多问题，最后我决定还是直接在solidworks里完成拓扑优化，这里记录一下流程。</p><h1 id="概述">1. 概述</h1><p>SolidworksSimulation中直接提供了拓扑优化的算例。目前只能针对<strong>单个零部件</strong>进行拓扑优化，无法考虑零部件之间的相对作用（如果有需要可以在ansys里完成）。整体拓扑优化的思路是首先用夹具对零件进行限位，对零件施加载荷，之后定义目标函数，在给定约束的情况下求解优化问题。</p><h1 id="具体流程">2. 具体流程</h1><h2 id="选择实体">2.1 选择实体</h2><p>首先在装配体文件中切换到simulation界面，点击新算例，选择拓扑算例：<img src="/blog/img/drone/新建算例.png" /></p><p>之后在模型中选取需要进行拓扑优化的零部件： <imgsrc="/blog/img/drone/选择实体.png" /></p><p>选中创建算例后可以看到如下界面： <imgsrc="/blog/img/drone/选择界面.png" /></p><h2 id="添加夹具">2.2 添加夹具</h2><p>之后我们在零部件上添加夹具。（连结部分暂时还不清楚作用，但是似乎不影响计算）添加夹具的意义在于对零件进行限位，常见的有固定夹具、弹簧夹具等。固定夹具的效果如下图：<img src="/blog/img/drone/Fixed-solid.gif" /></p><p>对于无人机碳板，我们固定其最外围一圈进行优化。</p><h2 id="添加外部载荷">2.3 添加外部载荷</h2><p>之后我们需要给零件添加外部载荷。可以选择添加力或者扭矩，修改力的方向。<img src="/blog/img/drone/外部载荷.png" /></p><p>这里需要注意的是我们可以选择分割操作，这样可以在零件的部分位置添加载荷。用于分割的草图需要我们在<strong>零部件</strong>文件里单独添加（装配体里的草图没有用）。另外可以选择按条目或者按总数进行分配，即选择多个面之后是每个面分配这么多载荷还是总共分配。</p><h2 id="目标和约束">2.4 目标和约束</h2><p>这里我们可以选择优化目标以及约束条件。常用的是最佳强度重量比，即选定需要减轻的重量，算出减轻重量后保留最大强度的方案。<img src="/blog/img/drone/目标和约束.png" /></p><h2 id="保留区域">2.5 保留区域</h2><p>可以看到无人机碳板上有许多孔洞，如果我们直接进行优化，这些孔洞很有可能会被扩充成更大的区域。为了保留这些孔洞特征，我们需要在制造控制选项中添加他们为保留的区域。<img src="/blog/img/drone/保留区域.png" /></p><p>此外在制造控制中我们还可以选择对称操作，这样拓扑优化出来的结果会更规则一些。</p><h2 id="网格划分">2.6 网格划分</h2><p>在网格划分中我直接选用了默认自动生成的网格，也可以根据需求在某些部分添加细化的网格。<img src="/blog/img/drone/网格划分.png" /></p><h1 id="优化结果">3. 优化结果</h1><p>最后优化的结果如图： <img src="/blog/img/drone/优化结果.png" /></p><p>我们可以手动在原本零件上按照优化结果所示进行切除操作。</p>]]></content>
    
    
    <categories>
      
      <category>CAD学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CAD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Deep reinforcement learning(2): Actor-Critic</title>
    <link href="/blog/2022/08/23/Deep%20reinforcement%20learning(2):%20Actor-Critic/"/>
    <url>/blog/2022/08/23/Deep%20reinforcement%20learning(2):%20Actor-Critic/</url>
    
    <content type="html"><![CDATA[<h1 id="从策略梯度到actor-critic">1. 从策略梯度到Actor-Critic</h1><p>上一章介绍了策略梯度的基本思想，最后得到的更新梯度的步骤可以写成如下形式：<span class="math display">\[\nabla_{\theta} J(\theta) \approx \frac{1}{N} \sum_{i=1}^{N}\sum_{t=1}^{T} \nabla_{\theta} \log \pi_{\theta}\left(\mathbf{a}_{i, t}\mid \mathbf{s}_{i, t}\right)\left(\mathbb{r}(\tau)-b\right)\]</span> 这里的问题是 <span class="math inline">\(r(\tau)\)</span>这一项是通过蒙特卡罗方法从 <spanclass="math inline">\(\pi_\theta(a|s)\)</span>中采样得到的，如果我们希望agent在与环境交互一次后就进行一次参数的优化，这里得到的梯度则只能根据单个样本计算，即得到一条轨迹后就代入上面的式子计算梯度，这样得到的结果很显然会有很大的方差。</p><p>为了解决这个问题，在Actor-Critic算法中，我们用Q函数来代替 <spanclass="math inline">\(r(\tau)\)</span>，并且创建Critic网络来拟合Q函数。这样我们将梯度重新写成：<span class="math display">\[\nabla_{\theta} J(\theta) = \frac{1}{N} \sum_{i=1}^{N} \sum_{t=1}^{T}\nabla_{\theta} \log \pi_{\theta}\left(\mathbf{a}_{i, t} \mid\mathbf{s}_{i, t}\right)\left(Q_{\theta}(\mathbf{a}_{i, t},\mathbf{s}_{i, t})\right)\]</span> Critic函数最后训练的目标是让 <spanclass="math inline">\(Q_{\theta}(\mathbf{a}, \mathbf{s})\)</span> 接近<spanclass="math inline">\(\mathbb{E}_{\theta}\left[r(\tau)\right]\)</span>，直观上理解就是我们通过已经收集到的reward拟合出一个函数来评估当前状态的好坏。和之前直接用每条轨迹的reward相比，这种方法保留了历史reward的信息，因此更加可靠。</p><p>这里我们还没有讨论具体该如何训练Critic网络。事实上在之后的推导中我们将会用监督学习来训练Critic网络，具体如何实现以及监督学习的训练集如何生成会在下一节里提到。</p><h1 id="从ac到a2c">2. 从AC到A2C</h1><p>基本的AC算法中我们在Critic网络中需要以state和action作为输入，输出Q函数。这样会带来两个问题：1.方差仍然很大；2.输入维度大（包括状态输入<span class="math inline">\(s\)</span> 和动作输入 <spanclass="math inline">\(a\)</span>），训练困难。为了解决这些问题我们对AC算法进行一些改进。</p><h2 id="引入基线">2.1 引入基线</h2><p>首先和Policygradient里一样，我们同样可以通过引入基线的办法来减小方差。这里的基线可以直接定义为给定状态情况下的价值函数<span class="math inline">\(V_\theta(s)\)</span>。与 <spanclass="math inline">\(Q_\theta(a,s)\)</span>相比，价值函数还没有对当前状态做出动作的选择，因此可以被当做是<strong>平均之后的<span class="math inline">\(Q(a,s)\)</span>函数</strong>。引入价值函数作为基线后，梯度可以重新被写成：</p><p><span class="math display">\[\nabla_{\theta} J(\theta) = \frac{1}{N} \sum_{i=1}^{N} \sum_{t=1}^{T}\nabla_{\theta} \log \pi_{\theta}\left(\mathbf{a}_{i, t} \mid\mathbf{s}_{i, t}\right)\left(A_{\theta}(\mathbf{a}_{i, t},\mathbf{s}_{i, t})\right)\]</span></p><p>其中 <span class="math inline">\(A_{\theta}(a_t,s_t)\)</span>函数我们定义为优势函数： <span class="math display">\[\begin{aligned}  A_{\theta}(a_t,s_t)&amp;=Q_{\theta}(a_t,s_t)-V_{\theta}(s_t)\end{aligned}\]</span></p><blockquote><p>事实上，这里的基线我们只需要选择一个与当前动作无关的函数，我们就能证明这里的梯度仍然是无偏估计。证明之后有空补上！</p></blockquote><h2 id="自助法采样bootstrapping">2.2 自助法采样(Bootstrapping)</h2><p>这里改进的基本思想是：如果我们需要采样一条轨迹来拟合优势函数，那采样的方差会特别大。然而如果我们只采样下一步的状态，方差相比采样整条轨迹就会大幅减小。</p><p><span class="math display">\[\begin{aligned}  A_{\theta}(a_t,s_t)&amp;=Q_{\theta}(a_t,s_t)&amp;-V_{\theta}(s_t)\\  &amp;=r(a_t,s_t)+\mathbb{E}_{s_{t+1}\simp(s_{t+1}|a_t,s_t)}\left[V_\theta(s_{t+1})\right]&amp;-V_\theta(s_t)\\  &amp;\approx r(a_t,s_t)+V_{\theta}(s_{t+1})&amp;-V_{\theta}(s_t)\end{aligned}\]</span></p><p>在这样近似之后，由于reward函数已知，我们只需要对价值函数进行拟合就能推算出优势函数。这样输入维度就只有状态变量了，大大节省了训练难度。</p><h2 id="生成训练集">2.3 生成训练集</h2><p>到此为止我们确定了我们需要拟合的函数就是价值函数 <spanclass="math inline">\(V(s_t)\)</span>，前文中提到，我们将会用监督学习的方法来拟合价值函数。即定义损失函数：<spanclass="math inline">\(\mathcal{L}(\theta)=\frac{1}{2}\sum_i||V_\theta(s_i)-y_i||^2\)</span>，同时收集训练集：<span class="math inline">\(\left\{ s_i, y_i\right\}\)</span>来优化损失函数。如何生成训练集就是我们接下来要讨论的问题。</p><h3 id="蒙特卡罗方法生成训练集">2.3.1 蒙特卡罗方法生成训练集</h3><p>最直观的方法就是我们直接通过采样一整条轨迹作为训练集。这里假设我们是通过与实际环境进行交互得到的轨迹，在这种情况下我们通常无法“重置”一个状态，这就意味着我们将会只有单样本的训练集（对于一个状态<span class="math inline">\(s\)</span> 我们只能生成一次轨迹来预测状态<span class="math inline">\(s\)</span> 之后 <spanclass="math inline">\(N\)</span>步的回报,理想情况下由于策略具有不确定性，我们是希望能够多次从一个状态出发，得到之后<span class="math inline">\(N\)</span>步的回报之后取平均值来减小预测的方差）。</p><p>利用蒙特卡罗方法得到的训练集可以写成：<spanclass="math inline">\(\left\{(s_{i,t}, \sum_{t&#39;=t}^Tr(s_{i,t&#39;},a_{i,t&#39;}))\right\}\)</span></p><h3 id="自助法估计训练集">2.3.2 自助法估计训练集</h3><p>和之前一样，我们可以用自助法估计 <spanclass="math inline">\(t+1\)</span> 时刻的状态，从而将累计回报近似为<span class="math inline">\(R+V\)</span>的形式。（与之前不同的是这里我们是对 <spanclass="math inline">\(V\)</span> 进行估计，在只有 <spanclass="math inline">\(s_t\)</span> 的情况下我们事实上需要多估计一步<spanclass="math inline">\(p_\theta(a_t|s_t)\)</span>，我认为这里事实上进行了两步Bootstrapping）。</p><p><span class="math display">\[y_{i,t}=\sum_{t&#39;=t}^T\mathbb{E}_\theta\left[r(s_{t&#39;},a_{t&#39;})\mids_{i,t}\right]\approx r(s_{i,t},a_{i,t})+V_\theta(s_{i,t+1})\]</span></p><p>这里的问题是即使我们拓展成这种形式，最根本的问题还是没有解决，我们不知道<span class="math inline">\(V_\theta(s)\)</span>的值。这里的解决办法就是假设上一次迭代得到的 <spanclass="math inline">\(V_{\hat{\theta}}(s)\)</span>与这次的差距很小，我们直接拿上一次的价值函数作为这次的估计。很显然这是个<strong>有偏估计</strong>，需要我们用其他实际的工程技巧来克服这个问题。</p><p>目前为止我们讨论的都是有限时间序列的情况，并且我们认为时间 <spanclass="math inline">\(t\)</span>是被计算到状态变量中的。假设我们现在需要解决无限时间序列，并且不考虑把时间<span class="math inline">\(t\)</span>作为状态考虑。这种情况下由于我们不断在价值函数上加一步回报 <spanclass="math inline">\(r(s_{t},a_{t})\)</span>，如果单步回报的期望大于0，那拟合的价值函数就会随迭代次数增加而不断增加，无法收敛。为了解决这个问题我们引入类似贝尔曼方程里的折扣因子的概念：<span class="math display">\[y_{i,t}\approx r(s_{i,t},a_{i,t})+\gamma V_\theta(s_{i,t+1})\]</span> 至此我们就得到了完成的A2C算法流程。</p><h1 id="从a2c到a3c">3. 从A2C到A3C</h1><p>原理很简单：同时让多个actor与环境分别单独进行交互，将交互的结果存入缓冲区中总结reward后统一对参数进行更新。<img src="/blog/img/drl_1/A3C.png" /></p>]]></content>
    
    
    <categories>
      
      <category>Deep reinforcement learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Deep reinforcement learning(1): Policy gradient</title>
    <link href="/blog/2022/07/15/Deep%20reinforcement%20learning(1):%20Policy%20gradient/"/>
    <url>/blog/2022/07/15/Deep%20reinforcement%20learning(1):%20Policy%20gradient/</url>
    
    <content type="html"><![CDATA[<p>此系列主要为 UCB CS285 深度强化学习系列课程学习笔记。</p><h1 id="问题描述">1. 问题描述</h1><h2 id="概率模型">1.1 概率模型</h2><p>忽略观测误差，深度强化学习解决的问题可以写成如下形式： <imgsrc="/blog/img/drl_1/model.png" />整个概率模型主要由两个部分组成，首先由当前状态<spanclass="math inline">\(s\)</span>通过当前的策略<spanclass="math inline">\(\pi_\theta\)</span>得到动作的概率分布，在动作的状态分布中采样得到下一步真正需要采取的动作<spanclass="math inline">\(a\)</span>，将<spanclass="math inline">\(a\)</span>作用于实际系统中得到下一个状态的概率分布<spanclass="math inline">\(p(s&#39;|s,a)\)</span>，实际系统生成反馈状态并形成闭环。</p><p>假设我们想研究未来<spanclass="math inline">\(T\)</span>时刻内策略参数设定为<spanclass="math inline">\(\theta\)</span>的模型，这整个概率分布模型可以写成：</p><p><span class="math display">\[p_\theta(s_1,a_1,s_2,a_2\dotss_T,a_T)=p(s_1)\prod_{i=1}^T\pi_\theta(a_i|s_i)p(s_{i+1}|s_i,a_i)\]</span></p><p>之后的表述会将整条状态轨迹写成<spanclass="math inline">\(\tau\)</span>，即 <spanclass="math inline">\(p_\theta(\tau)=p_\theta(s_1,a_1,s_2,a_2\dotss_T,a_T)\)</span></p><h2 id="目标函数">1.2 目标函数</h2><p>在得到上述概率模型后，我们需要明确需要优化的是什么。一般优化目标是关于动作和状态的函数，仍然假设我们要研究未来<spanclass="math inline">\(T\)</span>时刻内的策略，目标函数可以被写成：</p><p><span class="math display">\[J(\theta)=\mathbb E_{\tau\simp_\theta(\tau)}\left[\sum_{i=1}^Tr(s_i,a_i)\right]\]</span></p><p>深度强化学习的目标即通过调整<spanclass="math inline">\(\theta\)</span>使得目标函数的期望最大化。</p><h1 id="策略梯度">2. 策略梯度</h1><h2 id="reinforce法">2.1 REINFORCE法</h2><p>在得到上述的问题描述后，最简单直接的方法就是直接求目标函数对<spanclass="math inline">\(\theta\)</span>的梯度，之后用梯度上升法（因为需要最大化目标函数）逐步优化参数。这就是策略梯度的基本思想。</p><p><span class="math display">\[\nabla_\thetaJ(\theta)=\int\nabla_\theta p_\theta(\tau)r(\tau)d\tau\]</span></p><p>上面这个式子中，<span class="math inline">\(r(\tau)\)</span>表示对特定轨迹 <span class="math inline">\(\tau\)</span>的累计误差，积分的含义则表示在给定指定参数 <spanclass="math inline">\(\theta\)</span>的情况下，由于对应每个状态的动作并不是确定的，所以最后生成的轨迹会存在多种可能性，积分就是对这些轨迹的概率分布积分。下一步为了求解这一项，我们会引入一个<span class="math inline">\(\log\)</span> 函数的trick：</p><p><span class="math display">\[p_\theta(\tau)\nabla_\theta\logp_\theta(\tau)=p_\theta(\tau)  \frac{\nabla_\thetap_\theta(\tau)}{p_\theta(\tau)}=\nabla_\theta p_\theta(\tau)\]</span></p><p>根据这个trick我们对之前的积分进行变换：</p><p><span class="math display">\[\begin{align*}  \nabla_\theta J(\theta)&amp;=\int\nabla_\thetap_\theta(\tau)r(\tau)d\tau\\  &amp;=\int p_\theta(\tau)\nabla_\theta\log p_\theta(\tau)r(\tau)d\tau\\  &amp;=\mathbb{E}\left[\nabla_\theta\log p_\theta(\tau) r(\tau)\right]\end{align*}\]</span></p><p>把之前的概率分布代入这个式子中，由于是对 <spanclass="math inline">\(\theta\)</span>求梯度，初始状态概率分布以及状态转移分布都可以被忽略（与 <spanclass="math inline">\(\theta\)</span> 无关），最后梯度可以被写成：</p><p><span class="math display">\[\nabla_\theta J(\theta)=\mathbb{E}_{\tau\simp_\theta(\tau)}\left[\left(\sum_{i=1}^T\nabla_\theta\log\pi_\theta(a_i|s_i)\right)r(\tau)\right]\]</span></p><p>写成这个形式后我们就能通过采样的方法计算梯度，并采用梯度上升法来优化参数<spanclass="math inline">\(\theta\)</span>。这就是最基本的策略梯度REINFORCE方法：</p><ol type="1"><li>从 <span class="math inline">\(\pi_\theta(a|s)\)</span>中采样得到一系列轨迹 <span class="math inline">\(\tau_i\)</span></li><li>通过上述计算对当前策略进行评价，算出 <spanclass="math inline">\(J_\theta(\theta)\)</span> 和梯度</li><li>对参数进行梯度下降</li></ol><p>为了更深入理解这个梯度计算的形式，我们可以将它和监督学习的情况做对比。假设对于同样一个任务，我们还是需要学习特定状态下应该采取的行动<span class="math inline">\(\pi_\theta(a|s)\)</span>，不同的是这次我们有一系列已经标记过的数据 <spanclass="math inline">\((s_i,a_i)\)</span>，我们假设这些数据对应的策略就是最优策略，而我们就是要学习这个策略，这个问题就被变成一个监督学习问题。而此时目标函数的梯度可以写成如下形式：</p><p><span class="math display">\[\nabla_{\theta} J_{\mathrm{ML}}(\theta) \approx \frac{1}{N}\sum_{i=1}^{N}\left(\sum_{t=1}^{T} \nabla_{\theta} \log\pi_{\theta}\left(\mathbf{a}_{i, t} \mid \mathbf{s}_{i, t}\right)\right)\]</span></p><p>这里本质上就是最大似然估计，即通过训练使得标记的策略出现的可能性最大。不难发现这与我们推导出的梯度只相差一项<span class="math inline">\(r(\tau)\)</span>即整条轨迹上累计的回报。这里的直观理解就是最大似然估计会让给定的轨迹出现概率最大，而策略梯度法会让带有最大回报的轨迹出现概率最大。</p><h2 id="减小方差">2.2 减小方差</h2><p>如果我们直接使用上述方法对系统进行控制，通常会有很大的问题。其中一个问题就是梯度的方差过大，假设我们在每一步<span class="math inline">\(r(a_i,s_i)\)</span>上都加一个相同的常数，理论上这个系统和之前的没有区别，但是计算梯度时会产生很大的差别。</p><h3 id="通过因果关系简化梯度计算">2.2.1 通过因果关系简化梯度计算</h3><p>为了减少上面提到的方差问题，我们首先想到的是减小 <spanclass="math inline">\(\nabla_\theta J(\theta)\)</span>的值。这里可以通过因果关系得到小结论：<strong>假设我们有 <spanclass="math inline">\(t&lt;t&#39;\)</span> ，那么 <spanclass="math inline">\(t&#39;\)</span> 时刻的策略不会影响 <spanclass="math inline">\(t\)</span>时刻的回报</strong>。根据这个结论，我们可以在计算梯度时 <strong>只将<span class="math inline">\(t\)</span> 时刻后的回报和 <spanclass="math inline">\(t\)</span>时刻的似然概率相乘</strong>，并且能够证明这样得到的结果仍然是梯度的无偏估计：</p><p><span class="math display">\[\begin{align*}  \nabla_{\theta} J(\theta) &amp;\approx \frac{1}{N} \sum_{i=1}^{N}\sum_{t=1}^{T} \nabla_{\theta} \log \pi_{\theta}\left(\mathbf{a}_{i, t}\mid \mathbf{s}_{i, t}\right)\left(\sum_{t^{\prime}=1}^{T}r\left(\mathbf{s}_{i, t^{\prime}}, \mathbf{a}_{i,t^{\prime}}\right)\right)\\  &amp;= \frac{1}{N} \sum_{i=1}^{N} \sum_{t=1}^{T} \nabla_{\theta} \log\pi_{\theta}\left(\mathbf{a}_{i, t} \mid \mathbf{s}_{i,t}\right)\left(\sum_{t^{\prime}=t}^{T} r\left(\mathbf{s}_{i,t^{\prime}}, \mathbf{a}_{i, t^{\prime}}\right)\right)\end{align*}\]</span></p><h3 id="通过baseline方法减小方差">2.2.2 通过baseline方法减小方差</h3><p>这里的指导思想是，当我们评价一条轨迹的好坏时，我们先得到一个回报的平均值，再比较新的轨迹的回报与这个平均值。数学表达如下：</p><p><span class="math display">\[\nabla_{\theta} J(\theta) \approx \frac{1}{N} \sum_{i=1}^{N}\sum_{t=1}^{T} \nabla_{\theta} \log \pi_{\theta}\left(\mathbf{a}_{i, t}\mid \mathbf{s}_{i, t}\right)\left(\mathbb{r}(\tau)-b\right)\]</span></p><p><span class="math display">\[b = \frac{1}{N}\sum_{i=1}^N r(\tau)\]</span></p><p>我们可以证明通过这种方法，策略梯度的期望不会被改变，而方差则会减少。</p>]]></content>
    
    
    <categories>
      
      <category>Deep reinforcement learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022阅读计划(1)：霍乱时期的爱情</title>
    <link href="/blog/2022/05/26/%E9%9C%8D%E4%B9%B1/"/>
    <url>/blog/2022/05/26/%E9%9C%8D%E4%B9%B1/</url>
    
    <content type="html"><![CDATA[<h1 id="阅读动机">阅读动机</h1><p>2022年春天，笔者正在经历“新冠时期的爱情”。很早以前就听说过马尔克斯笔下曾经诞生过“霍乱时期的爱情”，原先认为笔者自己的经历中未曾出现过“霍乱”，对“爱情”的见解也很浅，这种状态恐怕无法体会其中的玄妙。很多时候文学诞生于现实，因此笔者一直认为缺乏现实经历会导致无法理解文学作品中传达的意境。这个时间节点重新捡起这本书也就是顺其自然的事情了。</p><p>然而较为可惜的是这篇小说刻画了霍乱与爱情之间各种错综复杂的关联，纷乱的纽带中却没有一条是指向霍乱对爱情的阻碍。其作为文学作品对笔者本人也就自然少了一层现实指导意义。</p><h1 id="摘抄">摘抄</h1><p><em>您在第 81 页（位置 #1100-1102）的标注 | 添加于2022年4月29日星期五 上午8:41:43</em></p><blockquote><p><em>这一次，换作是弗洛伦蒂诺·阿里萨看到了死神的面孔，因为当天下午，他收到一个信封，里面是一张从学校练习本的边缘撕下来的纸条，上面只有一行用铅笔写的回答：好吧，我同意结婚，只要您保证不逼我吃茄子。</em></p></blockquote><p>感同身受的狂喜。太喜欢“不吃茄子”这样的委婉让步了，像是两块天作之合的榫卯结构结合之际被瞬间抚平的木刺一样触动人心。</p><hr /><p><em>您在第 127 页（位置 #1724-1726）的标注 | 添加于2022年4月29日星期五 上午9:23:59</em></p><blockquote><p><em>实际上，这种疾病既不分肤色，也不分血统。而就如突然开始一样，它又突然停止了。从来没有人知道它到底造成了多大规模的伤害，不是因为无法统计，而是因为我们最常见的美德之一就是家丑不可外扬。</em></p></blockquote><p>似乎非常贴合实际？</p><hr /><p><em>您在第 128 页（位置 #1745-1748）的标注 | 添加于2022年4月29日星期五 上午9:26:03</em></p><blockquote><p><em>在那之前，胡维纳尔·乌尔比诺医生和他的家人一直都将死亡视作发生在别人家的不幸，它发生在别人的父母、兄弟姐妹、丈夫妻子身上，却从来不会降临在自己的亲人头上。他们一家人的生命节奏都很缓慢，在他们身上看不出衰老、生病和死亡的迹象，他们只会在自己的时间里慢慢消失，然后变成一个时代的回忆和云雾，直至最终被遗忘吞没。</em></p></blockquote><p>死亡大概是这篇小说里反复提及的话题。它终究会发生，却让人没有任何真实触感。直到降临之际才以可怖的姿态猝然出现，在人们还没来得及对它建立认知之前将一切席卷一空。有的时候会觉得纪念他们，就像是用回忆在拼命补救当时的猝不及防，但是早做心理准备一切也并不会有不同，这是每个人无法逃避的宿命，这种措手不及也本就是其中一环罢了。</p><hr /><p><em>您在第 129 页（位置 #1748-1754）的标注 | 添加于2022年4月29日星期五 上午9:27:03</em></p><blockquote><p><em>尽管，他最早的回忆之一—九岁或十一岁时—在某种程度上便是从父亲身上看到了死亡早早发出的信号。那是一个下着雨的下午，他们两人待在家中的办公室。他正用彩色粉笔在地砖上画云雀和向日葵，父亲则对着窗子的亮光在看书，背心敞着扣，衬衫袖子上勒着橡皮筋。忽然，他停止了阅读，用一根末端带有银抓手的爪杖挠了挠后背。因为够不着，他又让儿子用指甲帮他抓一抓。儿子这样做时，他产生了一种奇怪的感觉，仿佛感觉不到自己的脊背似的。最后，父亲从肩膀上方看着儿子，凄惨地笑了笑。“如果我现在就死了，”他说，“等你到了我这个年纪，可能都不记得我了。”</em></p></blockquote><p><em>您在第 129 页（位置 #1754-1757）的标注 | 添加于2022年4月29日星期五 上午9:27:14</em></p><blockquote><p><em>没有任何明显的理由，他就说出了这样一句话。死亡天使在办公室那凉爽的昏暗中一闪而过，又从窗子飞了出去，所到之处，散落下几片羽毛，但孩子却没有看见。自那时起，已经过去了二十多年，胡维纳尔·乌尔比诺马上就要到父亲那天下午的那个年纪了。他知道自己和父亲很像，而现在除了这一点外，他还惊愕地意识到，和父亲一样，自己也终将死亡。</em></p></blockquote><p>很喜欢类似的死亡比喻，小时候曾是类似比喻的狂热爱好者。看到这段描述的时候脑子里想到另一个比喻，大概是在小学的时候接触到的，现在已经没办法分清是自己琢磨出来的还是在其他作品中看到的：<em>在睡前窝在被子里的时候突然想到死亡的概念，恍然想到死亡就是第二天再也体会不到蜷缩在被子里时本应该受到的包裹感和温热感。</em>刚刚手动搜了半天没找到来源，姑且当成原创吧。</p><hr /><p><em>您在第 214 页（位置 #2913-2917）的标注 | 添加于2022年5月13日星期五 上午3:13:31</em></p><blockquote><p><em>已经太迟了：机会曾经就在那辆骡子轨道车上，后来也一直在她所坐的这把椅子上，而现在却已一去不复返了。事实上，在为他干了那么多见不得人的卑鄙事，为他忍受了那么多肮脏的勾当之后，她的生命已经走到了他的前面，尽管他原本比她年长二十岁：她为他衰老了。她是那么地爱他，她愿意继续爱他而非欺骗他，但她不得不以一种残酷的方式点醒他。</em></p></blockquote><p>这里是在描述助理LeonaCassiani和男主之间的感情。wiki中对她的描述如下：</p><blockquote><p>She starts out as the "personal assistant" to Uncle Leo XII at theR.C.C., the company which Florentino eventually controls. At one point,it is revealed that the two share a deep respect, possibly even love,for each other, but will never actually be together. She has a maternallove for him as a result of his "charity" in rescuing her from thestreets and giving her a job.</p></blockquote><p>其中所谓母性的爱(maternallove)是他们之间感情最贴切的表述，有些难以体会和理解这样的关系。</p><hr /><p><em>您在第 233 页（位置 #3169-3173）的标注 | 添加于2022年5月18日星期三 上午12:47:36</em></p><blockquote><p><em>不知怎的，在一次关于弗洛伦蒂诺·阿里萨的偶然谈话中，她突然发现了其中的奥秘。所有参加那次聚会的人都知道他是正值鼎盛时期的加勒比河运公司的接班人，很多人都十分肯定曾见过他多次，甚至还和他打过交道，但没有一个人记得清他是什么模样。于是，费尔明娜·达萨发现了潜意识中阻碍她爱他的原因。她说：“他就好像不是一个人，而是一个影子。”的确如此：他是一个谁都不认识的人的影子。</em></p></blockquote><p>大概是全篇中最直接表述费尔明娜·达萨拒绝弗洛伦蒂诺·阿里萨的理由。事实上小说最后费尔明娜·达萨训斥自己女儿对他们之间爱情的轻蔑时认为是当时的时代拆散了她与弗洛伦蒂诺·阿里萨，在笔者本人看来更像是一种借口。对她来说每当她倾向于认同自己和弗洛伦蒂诺·阿里萨之间的关系就是爱情时，她总会下意识将这种关系与弗洛伦蒂诺·阿里萨本人之间进行切割。无论是青梅竹马时期的情书还是老年时期的出游，她似乎都在将这些令她愉快的特质单独提取出来，与生成的影子恋爱。</p><hr /><p><em>您在第 256 页（位置 #3491-3493）的标注 | 添加于2022年5月22日星期日 上午7:16:57</em></p><blockquote><p>*无论她把那时的记忆转向哪里，都会迎头碰上弗洛伦蒂诺·阿里萨。可她始终还是保持了足够的冷静，分辨出那并非对爱的回忆，也不是对后悔的回忆，而是对一个曾使她泪水涟涟的痛苦形象的回忆。她没有发觉，她正被同情的陷阱威胁，而正是这同样的陷阱，让那么多毫无准备的受害者在弗洛伦蒂诺·阿里萨那里失去了贞洁。</p></blockquote><p>和上一段类似，她将重新萌生的感情归因于同情的陷阱。当然爱情的本质也许就是这样，通过对方所带来的附带价值产生吸引，抑或是存在真正的抛去一切附带价值的爱情。</p><p>另外这里对爱情的描述也呼应了标题中霍乱与爱情的其中一层联系，将爱情表述为某种传染病。</p><hr /><p><em>您在第 257 页（位置 #3497-3499）的标注 | 添加于2022年5月22日星期日 上午7:17:47</em></p><blockquote><p><em>无理取闹，以及夫唱妇随的那种神话般的荣耀之光。那是他们相爱得最美好的时期，不慌不忙，适宜得体，对于共同战胜逆境所取得的不可思议的胜利，他们比任何时候都更了然于心，也更心存感激。当然，生活还将给他们更多致命的考验，但那已经无关紧要了：他们已到达了彼岸。</em></p></blockquote><p><em>您在第 344 页（位置 #4678-4682）的标注 | 添加于2022年5月23日星期一 上午8:41:58</em></p><blockquote><p><em>曾有一天，她绝望之极，冲他喊道：“你就没有发现我一点也不幸福吗？”而他以他特有的姿势摘下眼镜，不温不火，用他那孩童般天真的眼睛中的一汪清水淹没了她，只说了一句话，就让她体会到他那令人难以忍受的智慧的全部分量：“你要永远记住，对于一对恩爱夫妻，最重要的不是幸福，而是稳定。”从守寡最初的寂寞时光开始，她便明白，这句话中隐藏的并不是她当初所认为的卑劣威胁，而是一块为两人带来过无数幸福时光的月亮宝石。</em></p></blockquote><p>大概是笔者期望的爱情。</p><hr /><p><em>您在第 283 页（位置 #3849-3855）的标注 | 添加于2022年5月23日星期一 上午7:46:42</em></p><blockquote><p><em>他能清楚地感觉到自己肝脏的形状，无须触摸就能说出它的大小。他感到自己的肾脏发出像熟睡的猫一样的哼叫；感到胆囊在闪闪发光；感到血液在动脉里嗡嗡作响。有时，他像一条喘不上来气的鱼一样醒来，觉得心脏里积满了水。他觉得心脏瞬间乱了步伐，觉得它的脉动延迟了一下，就像当初在学校里参加军训时那样，继而一次又一次地延迟。最后，他又觉得它恢复了正常，因为上帝是伟大的。但他没有求助于曾开给病人的那些分散注意力的药物，而是被恐惧折磨得晕头转向。的确，五十八岁时，他生活中唯一需要的，依然是一个懂他的人。为此，他求助于费尔明娜·达萨，这个世界上最爱他、也是他最爱的人，在她这里，他刚刚让自己的良心得到了平静。</em></p></blockquote><p>这段只是觉得自己身体有时也会发出类似的信号，有时会特别专注于某段血管中血液的流动。文中是在表示感受到衰老，希望对自己不是同样的含义吧。</p><hr /><p><em>您在第 320 页（位置 #4346-4348）的标注 | 添加于2022年5月23日星期一 上午8:20:14</em></p><blockquote><p><em>她想找回自我，重获半个世纪奴仆般生活中被迫放弃的一切。那种生活无疑曾使她幸福，然而丈夫一死，她甚至无法找到自我的一点点痕迹。她像是别人家中的一个幽灵，漫无目的地游荡在一夜之间变得空阔而孤寂的房子里，不断痛苦地自问，究竟谁是亡者：是死去的丈夫，还是她这个留下来的人。</em></p></blockquote><p>不太能欣赏抛弃自我的爱情，或者在笔者看来，这并不算是爱情，而只能是精神的早衰，需要靠精神寄托来维持仅剩的一点活力。</p><hr /><blockquote><p><em>您在第 336 页（位置 #4568-4572）的标注 | 添加于2022年5月23日星期一 上午8:33:53</em></p></blockquote><p><em>所以，他像筹划最后一场决战那样，对每个细枝末节都思虑周详：一切都要与众不同，如此方能在一个于巅峰上过完一生的女人心中激起新的好奇、新的兴致和新的希望。这封信应该要提供一种蠢蠢欲动的幻想，并且给予她足够的勇气，把某个阶层的不公偏见扔进垃圾堆里去。她原本并不出身于那个阶层，可那个阶层最终却变得比其他任何阶层都更像她的出身之处。这封信应该教会她把爱情想成一种美好的状态，而非达到任何目的的途径，爱情自有其本身的起点和终点。</em></p><blockquote><p><em>您在第 343 页（位置 #4659-4666）的标注 | 添加于2022年5月23日星期一 上午8:40:37</em></p></blockquote><p><em>那是对人生、爱情、老年和死亡的思考：这些想法曾无数次像夜间的鸟儿一般扑扇着翅膀掠过她的头顶，可每当她想抓住它们时，它们就惊飞四散，只剩下散落的片片羽毛。而如今，它们就在这里，清晰明了，正如她自己原本想表达的那样。她又一次感到难过，丈夫已经不在了，无法再和他一起讨论这些，就像每晚睡前他们都会讨论这一天发生的事情一样。由此，她发现了一个陌生的弗洛伦蒂诺·阿里萨，他的真知灼见和他年轻时那些炽热的情书不相符，也和他一生阴郁的举止不相符。他的话更像是出自一个埃斯科拉斯蒂卡姑妈所认为的受到圣神启示的男人之口。这个想法又让她像第一次收到他的信时那样害怕起来。但无论如何，最令她安心的是，她确信这封由一个睿智老人所写的信并非试图重申葬礼那天的无礼言语，而是意在抹掉过去，可谓高尚之举。</em></p><p>弗洛伦蒂诺·阿里萨把握住了费尔明娜·达萨的爱情观并借此抓住了她的心。让人感慨的是他并不在乎费尔明娜·达萨是否与自己有着同样的爱情观，因为对于他来说，一致的爱情观并不是他在追求这段关系中的其中一个目标。可能这也与笔者所期望的相似。有时候情感上的共鸣并不意味着一定有一致的价值观，反过来说，一致的价值观也并不能带来爱情。</p><hr /><blockquote><p><em>您在第 341 页（位置 #4626-4627）的标注 | 添加于2022年5月23日星期一 上午8:38:20</em></p></blockquote><p><em>弗洛伦蒂诺·阿里萨感到，暮年的岁月不是奔涌向前的激流，而是一个无底的地下水池，记忆从这里慢慢流走。他的智慧渐渐枯竭。</em></p><hr /><p><em>您在第 351 页（位置 #4766-4771）的标注 | 添加于2022年5月23日星期一 上午8:46:49</em></p><blockquote><p><em>两人都有些胆怯，都不知道在距离年轻岁月已如此遥远的时候，在一座不属于他们的房子里，在用来下象棋的露台上，在还飘着墓地花香的地方，究竟要做些什么。这是半个世纪后两人第一次面对面地坐在一起，距离是如此之近，并且有充足的时间静静地看着对方。他们看得如此清楚：这两个被死神窥视的老人，没有旁的什么共同之处，一起享有的只是对那个短暂过去的回忆，然而那个回忆早已不再属于他们，而是属于两个消失了的年轻人，那两个人足可以做他们的孙子了。她想，他最终会说服自己，会看到这梦想是多么的不现实，从而把他自己从荒唐中解救出来。</em></p></blockquote><hr /><p><em>您在第 372 页（位置 #5056-5058）的标注 | 添加于2022年5月23日星期一 上午9:06:11</em></p><blockquote><p><em>一个世纪前，人们毁掉了我和这个可怜男人的生活，因为我们太年轻；现在，他们又想在我们身上故伎重施，因为我们太老了。”她用烟蒂点燃另一支香烟，将侵蚀着她五脏六腑的毒气彻底呼出体外。</em></p></blockquote><hr /><p><em>您在第 391 页（位置 #5318-5323）的标注 | 添加于2022年5月23日星期一 上午9:25:27</em></p><blockquote><p><em>他拿起她的手，把它放在自己的胸口上：费尔明娜·达萨几乎能清清楚楚地感受到他那颗不知疲倦的老人之心正以年轻人的力量、速度和慌乱跳动着。他说：“过多的爱和过少的爱都对它有害。”但他说这话时并没有信心，事实上，他羞愧难当，正和自己怄气，渴望找个理由把失败归咎于她。她看出了这一点，开始用嘲弄似的爱抚挑逗这个毫无自卫能力的身体，就像一只残忍地幸灾乐祸的温柔小猫。终于，他无法再忍受这种折磨，起身回自己的舱室去了。她一直想着他，直到天亮，终于确认了自己对他的爱。随着茴香酒带来的醉意散去，她独自漂浮在缓慢的海浪中，忧郁渐渐袭上心头，她担心他生她的气，不会再来了。</em></p></blockquote><hr /><p><em>您在第 395 页（位置 #5360-5367）的标注 | 添加于2022年5月23日星期一 上午9:28:26</em></p><blockquote><p><em>“我们来假设一下，”他说，“有没有可能做一次直航，既不载货，也不运送旅客，不在任何港口停靠，总之就是，途中什么都不做？”船长说，这只在假设中成立。CFC有各种劳务协议，这一点弗洛伦蒂诺·阿里萨比谁都清楚，关于载货、载客、邮件运输以及其他很多项义务都签有合同，其中大部分是不能推卸的。唯有一种情况可以跳过一切条款，那就是船上发生瘟疫。轮船宣布进入隔离检疫，升起黄旗，在紧急状态下航行。由于沿河出现过很多次霍乱，萨马利塔诺船长曾有好几次不得不这样做，尽管后来卫生部门强迫医生签署了死者死于普通痢疾的证明。此外，在这条河流的历史上，很多时候轮船升起代表瘟疫的黄旗是为了逃避税收，或是不愿搭载某个乘客，又或是躲避不合时宜的检查。弗洛伦蒂诺·阿里萨在桌下找到了费尔明娜·达萨的手。</em></p></blockquote><p>就如之前所说，霍乱在本书中与爱情有千丝万缕的联系，这里应该是书中最为直接描述的一种关系，即霍乱阴差阳错的成为了男女主爱情的助推剂。</p><hr /><p><em>您在第 398 页（位置 #5406-5410）的标注 | 添加于2022年5月23日星期一 上午9:31:04</em></p><blockquote><p><em>他们仿佛一举越过了漫长艰辛的夫妻生活，义无反顾地直达爱情的核心。他们像一对经历了生活磨炼的老夫老妻，在宁静中超越了激情的陷阱，超越了幻想的无情嘲弄和醒悟的海市蜃楼：超越了爱情。因为他们已在一起生活了足够长时间，足以发现无论何时何地，爱情始终都是爱情，只不过距离死亡越近，爱就越浓郁。</em></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>2022阅读计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Reading</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Docker配置ROS noetic环境</title>
    <link href="/blog/2022/05/16/ros_docker/"/>
    <url>/blog/2022/05/16/ros_docker/</url>
    
    <content type="html"><![CDATA[<h1 id="提要">1. 提要</h1><p>最近需要将一段感知代码移植到实验室的pipeline上进行测试，然而之前一直在使用ROS_melodic，原始感知代码目前只在melodic上测试成功，为了实验室其他用noetic的老哥们能测试，就想搭建一个noetic的docker来尝试一下同样的代码能否在noetic上编译成功。（借机学习一下docker）</p><h1 id="安装过程">2. 安装过程</h1><h2 id="安装docker">2.1 安装Docker</h2><p>这一步基本参考<ahref="https://yeasy.gitbook.io/docker_practice/install/ubuntu">Docker-从入门到实践</a><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="“Docker-从入门到实践” https://yeasy.gitbook.io/docker_practice/ (accessed May 12, 2022).">[1]</span></a></sup>的教程，最后在测试安装是否成功时遇到了permission相关的问题，最终通过下面这行代码扩充权限解决：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo <span class="hljs-built_in">chmod</span> 666 /var/run/docker.sock<br></code></pre></td></tr></table></figure> ## 2.2 安装ROS镜像 这一步参考<ahref="http://wiki.ros.org/docker/Tutorials/Docker">ROS官方网站</a><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="“docker/Tutorials/Docker - ROS Wiki.” http://wiki.ros.org/docker/Tutorials/Docker (accessed May 12, 2022).">[2]</span></a></sup>提出的教程，其中部分步骤有差异，因此这里完整记录一下。</p><p>首先下载ROS container镜像： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker pull ros<br></code></pre></td></tr></table></figure>之后下载noetic所需要的最基本的环境镜像： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker pull ros:noetic<br><span class="hljs-comment">## 如果需要下载noetic全部功能:</span><br><span class="hljs-comment"># docker pull osrf/ros:noetic-desktop-full</span><br></code></pre></td></tr></table></figure>最后一步启动镜像（与官网描述有所不同）： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -it ros:noetic<br></code></pre></td></tr></table></figure>在启动的bash中尝试启动<code>roscore</code>，如果成功就表示配置完成啦！</p><h1 id="基本操作">3. 基本操作</h1><p>首先引入一下docker的基本概念，主要是<strong>镜像(image)、容器(container)</strong>的概念。这里可以将镜像理解为c++中定义的类的概念，而容器是该类实例化之后的对象。在上一章中所提到的<code>docker run</code>的操作就可以理解为根据提供的镜像创建一个容器。运行选项<code>-it</code>的含义如下：</p><blockquote><p>-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上，-i 则让容器的标准输入保持打开。</p></blockquote>通过vscode插件，我们可以很方便地对镜像和容器进行管理。其操作界面如下图：<p style="text-align: center;"><img src="/blog/img/ros_docker/1.png" width=300></p><p>在container中可以很方便地进行运行和终止容器的操作，也可以删除不需要的容器。最右边的灰字为容器的名称（返回到之前提到c++中类的类比，这里的名字可以理解为变量名），通过下面的files可以对容器中的文件进行管理。</p><p>后续有时间会更新一些dockerfile的使用，目前只手动在docker中安装了<code>git</code>以及<code>catkin tool</code>，似乎这些步骤都能直接写进dockerfile中。</p><h1 id="参考">参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>“Docker-从入门到实践”https://yeasy.gitbook.io/docker_practice/ (accessed May 12, 2022).<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>“docker/Tutorials/Docker -ROS Wiki.” http://wiki.ros.org/docker/Tutorials/Docker (accessed May 12,2022). <a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>ROS学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ROS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fluent入门学习（2）：热电单向耦合分析</title>
    <link href="/blog/2020/09/24/fluent_2/"/>
    <url>/blog/2020/09/24/fluent_2/</url>
    
    <content type="html"><![CDATA[<h1 id="提要">1. 提要</h1><p>使用fluent和thermoelectric模块进行热电模拟，其中热电部分为单向耦合，即仅通过塞贝克效应考虑温度对电的影响。其中一些概念仅为笔者自己的理解，如有谬误欢迎各位提出讨论！</p><h1 id="基本概念">2. 基本概念</h1><h2 id="塞贝克效应">2.1 塞贝克效应</h2><p>通过半导体材料两边稳定的温差能够形成电势差，又称为热电第一效应，基本公式为：</p><p><span class="math display">\[V_{ab} = \int_{T_1}^{T_2} (S_B-S_A)(T_2-T_1)dT\]</span></p><p>对单个材料定义绝对塞贝克系数：</p><p><span class="math display">\[S=\lim\limits_{\Delta T\to0}\frac{V}{\Delta T}\]</span></p><h2 id="综合热电效应总结">2.2 综合热电效应总结</h2><p><imgsrc="https://img-blog.csdnimg.cn/20200924110431136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mzk1MjU2,size_16,color_FFFFFF,t_70#pic_center" /># 3. 几何建模和网格划分 # 3.1 几何建模 <imgsrc="https://img-blog.csdnimg.cn/20200924110711650.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mzk1MjU2,size_10,color_FFFFFF,t_70#pic_center" />几何部分设计两组pn结，外电路部分设计为一个闭环。设定上方为冷源和散热片，下方为热源。</p><h1 id="网格划分">3.2 网格划分</h1><p><imgsrc="https://img-blog.csdnimg.cn/20200924111122922.png#pic_center" />对于流场部分设定inflation边界层。 <imgsrc="https://img-blog.csdnimg.cn/20200924111252313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mzk1MjU2,size_10,color_FFFFFF,t_70#pic_center" />对于几何较为规整的pn结、电阻等部分使用扫略的网格生成方式，但是底部连接部分扫略网格出现畸变，目前还没有解决方法。<imgsrc="https://img-blog.csdnimg.cn/20200924111411686.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mzk1MjU2,size_16,color_FFFFFF,t_70#pic_center" /># 4.Fluent流场热部分求解打开能量方程-添加材料性质-设定边界条件-设置求解方法-初始化-计算求解接触面温度场： <imgsrc="https://img-blog.csdnimg.cn/20200924114640608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mzk1MjU2,size_16,color_FFFFFF,t_70#pic_center" /># 5.热电耦合设置 ## 5.1材料设置 添加单独的热电模块之后在engineeringdata中添加所需材料，其中pn结与电阻材料需要自定义，添加新材料后增加所需要的性质。（电阻材料除了电导率外需要再添加其他性质，否则最后计算时会出现licsence权限问题，无法计算纯电学问题）<imgsrc="https://img-blog.csdnimg.cn/20200924115153674.png#pic_center" /> ##5.2几何和网格处理在workbench中导入和之前模型一致的几何，在model中添加材料的对应并生成自动网格（这里网格不需要与之前的网格一致，并且不需要考虑流场，可以将流体域部分以及散热片部分的几何抑制）<imgsrc="https://img-blog.csdnimg.cn/20200924115452469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mzk1MjU2,size_16,color_FFFFFF,t_70#pic_center" />## 5.3边界条件设置与结果查看 1）在importedload中新增temperature边界条件，选中与散热片的连接面。2）在总边界条件中增加下表面的温度条件。 3）选中一个交界面作为电势0点。<imgsrc="https://img-blog.csdnimg.cn/20200924115736570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mzk1MjU2,size_16,color_FFFFFF,t_70#pic_center" />设置好边界条件后进行求解。 温度场： <imgsrc="https://img-blog.csdnimg.cn/20200924115837928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mzk1MjU2,size_16,color_FFFFFF,t_70#pic_center" />电流密度： <imgsrc="https://img-blog.csdnimg.cn/20200924115858693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mzk1MjU2,size_16,color_FFFFFF,t_70#pic_center" />电势场： <imgsrc="https://img-blog.csdnimg.cn/20200924115914591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mzk1MjU2,size_16,color_FFFFFF,t_70#pic_center" /></p>]]></content>
    
    
    <categories>
      
      <category>fluent入门学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CFD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fluent入门学习（1）：三维卡门涡街算例</title>
    <link href="/blog/2020/08/13/fluent_1/"/>
    <url>/blog/2020/08/13/fluent_1/</url>
    
    <content type="html"><![CDATA[<h1 id="提要">1. 提要</h1><p>从零开始学习fluent流体仿真的一些记录，此次学习建立效果较为明显且不需要实验验证的卡门涡街现象的仿真以熟悉大致流程，主要采用solidworks进行模型设计，ICEM进行网格划分。其中一些概念仅为笔者自己的理解，如有谬误欢迎各位提出讨论！</p><h1 id="基本流程">2. 基本流程</h1><p>solidworks进行流场建模，spaceclaim进行几何处理，ICEM进行结构网格划分，最后在fluent中设定材料与边界条件得出计算结果</p><h1 id="spaceclaim的几何预处理">3. SpaceClaim的几何预处理</h1>在solidworks中我们主要对固体部分的几何进行了建模，实际分析过程中则主要考察流体的特性，因此需要提取出流体域。这里几何比较简单，只需要使用体积抽取功能，选中能够和几何图形形成封闭空间的面，再选中空间内的任意一个面。（注意：几何图形目前来看需要是一个体而不是多个体合成的，因此本例中如果在solidworks中创建几何时使用了多次拉伸，需要在体积抽取前将多个体合并为一个part）<p style="text-align: center;"><img src="https://img-blog.csdnimg.cn/20200819162016951.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mzk1MjU2,size_16,color_FFFFFF,t_70#pic_center" width=200></p><p>本例中几何处理只需要进行这一步。另外由于这里是流固单向耦合，仅考虑固体对流体的单向作用，因此不需要对固体部分进行网格划分，可以选择在这一步就将固体部分的块抑制（supress）。</p><h1 id="icem结构网格划分">4. ICEM结构网格划分</h1>ansys提供了独立的网格划分模块ICEM，我们可以利用它进行非结构或结构网格的划分。这里介绍一下结构网格与非结构网格的区别：1）非结构网格：由提前设定的参数（网格大小、网格类型四面体或六面体等）自动生成的网格。2）结构网格：首先对几何进行抽象，绘制出反应几何特征的块（block），由块到几何建立一一映射。由于块一般为较为规整的几何形状，因此由块生成的网格一般较为整齐，多为六面体网格<p style="text-align: center;"><img src="https://img-blog.csdnimg.cn/20200819162944643.png#pic_center" width=500></p><p>ICEM中的几何不存在体的概念，而只有点、曲线和面，最终形成的网格是在面围成的封闭空间内形成的。首先对所有面进行命名，右边栏part右键createpart功能，选中需要的面进行命名。</p><p style="text-align: center;"><img src="https://img-blog.csdnimg.cn/20200819163307528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mzk1MjU2,size_16,color_FFFFFF,t_70#pic_center" width=300></p>命名完成后建立整体的块，这个块是基于已有几何的外部框架搭建的，本例中为一个长方体，其边界与顶点已经一一和几何对应了，之后不用再重复定义。<p style="text-align: center;"><img src="https://img-blog.csdnimg.cn/20200819163717805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mzk1MjU2,size_16,color_FFFFFF,t_70#pic_center" width=600></p><p>创建完成后对块进行划分。 <imgsrc="https://img-blog.csdnimg.cn/20200819163808356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mzk1MjU2,size_16,color_FFFFFF,t_70#pic_center"alt="在这里插入图片描述" />删去中间圆柱部分的块，建立圆柱周长和两组四条边的映射关系，设置全局网格大小后初步建立网格。<imgsrc="https://img-blog.csdnimg.cn/20200819163945342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mzk1MjU2,size_16,color_FFFFFF,t_70#pic_center"alt="在这里插入图片描述" />针对产生畸变严重部分进行顶点的调整后将网格质量提升到0.85以上。 <imgsrc="https://img-blog.csdnimg.cn/20200819164123857.png#pic_center"alt="在这里插入图片描述" /></p><p>针对较稀疏的边使用edgeparams进行设置，增加节点个数：（1.同样能设定增长率，实现边界层效果的设计2.进行参数复制可以将参数复制到平行的edge上） <imgsrc="https://img-blog.csdnimg.cn/20200819164150295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mzk1MjU2,size_16,color_FFFFFF,t_70#pic_center"alt="在这里插入图片描述" /> <imgsrc="https://img-blog.csdnimg.cn/20200819164200151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mzk1MjU2,size_16,color_FFFFFF,t_70#pic_center"alt="在这里插入图片描述" />针对圆柱周边可能出现的边界层进行加密。（网格在五位数数量级时计算速度+精度较为合理）</p><h1 id="fluent求解器设置">5. fluent求解器设置</h1><p>general中能够进行网格质量的检查，以及是求解瞬态还是稳态情况。 <imgsrc="https://img-blog.csdnimg.cn/20200819164927594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mzk1MjU2,size_16,color_FFFFFF,t_70#pic_center"alt="在这里插入图片描述" />之后需要在models中开启需要模拟的物理方程，默认只有流体粘度模型，本例中也只需要开启这个。<img src="https://img-blog.csdnimg.cn/20200819165110520.png#pic_center"alt="在这里插入图片描述" />之后进行材料设置和进出口条件设置，将流体域的材料改为液态水，进口速度根据卡门涡街产生的雷诺数范围粗略计算为20m/s，其余皆为默认。method中选择迭代方法，这里介绍常用算法SIMPLE算法，其主要根据不可压缩流体的连续性方程以及N-S方程进行迭代，在上述两个方程中速度场与压强场相互耦合，通过初始化压强场，由NS方程得出对应速度场，再由连续性方程进行修正之后反复迭代。迭代算法完成后在residual中设置残差要求后进行初始化，由于这个例子中为瞬态求解因此还需要在计算页中设定求解时间步长、步数、每个时间步长的迭代次数，最后进行计算。<imgsrc="https://img-blog.csdnimg.cn/20200819165904277.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mzk1MjU2,size_16,color_FFFFFF,t_70#pic_center"alt="在这里插入图片描述" />后处理可以使用fluent自带或者ansys中的cfd-post，如果需要展示动画需要在计算之前提前在calculationactivities中添加需要观测的云图，这里得到的结果如下：</p><p style="text-align: center;"><img src="https://img-blog.csdnimg.cn/20200819170156853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mzk1MjU2,size_16,color_FFFFFF,t_70#pic_center" width=600></p><p style="text-align: center;"><img src="https://img-blog.csdnimg.cn/20200819170239399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mzk1MjU2,size_16,color_FFFFFF,t_70#pic_center" width=630></p><p>可以观测到涡旋的脱落。</p>]]></content>
    
    
    <categories>
      
      <category>fluent入门学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CFD</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
